---
phase: 01-runtime-guardrails-and-ipc-backbone
plan: 06
type: execute
wave: 4
depends_on:
  - 01-02
  - 01-03
  - 01-05
files_modified:
  - src/main/index.ts
  - src/main/ipc/runtime-controller.ts
  - src/renderer/index.tsx
  - src/preload/index.ts
  - .planning/phases/01-runtime-guardrails-and-ipc-backbone/01-runtime-guardrails-and-ipc-backbone-VERIFICATION.md
  - .planning/phases/01-runtime-guardrails-and-ipc-backbone/01-UAT.md
autonomous: true
must_haves:
  truths:
    - "If a worker crashes during use, the app reconnects automatically without requiring app relaunch."
    - "Incompatible worker handshake/version combinations are rejected and surfaced with clear fix-first guidance instead of undefined behavior."
    - "App launch shows the runtime bridge UI (`Scribe-Valet` and `Runtime bridge status: connected`) rather than a blank window."
  artifacts:
    - path: "src/main/index.ts"
      provides: "Main bootstrap wiring for worker supervisor lifecycle, runtime status actions, and renderer entry loading"
      contains: "WorkerSupervisor"
    - path: "src/renderer/index.tsx"
      provides: "Mounted AppShell runtime recovery UI plus trust/status shell"
      contains: "AppShell"
    - path: ".planning/phases/01-runtime-guardrails-and-ipc-backbone/01-runtime-guardrails-and-ipc-backbone-VERIFICATION.md"
      provides: "Updated verification evidence for ARCH-01 and ARCH-02 wiring outcomes"
      contains: "status:"
  key_links:
    - from: "src/main/index.ts"
      to: "src/main/supervisor/worker-supervisor.ts"
      via: "bootstrap creates supervisor instance and starts lifecycle management"
      pattern: "new WorkerSupervisor|\.start\(\)"
    - from: "src/main/index.ts"
      to: "src/main/ipc/runtime-controller.ts"
      via: "runtime:get-status and runtime:status:changed registration targets BrowserWindow webContents"
      pattern: "registerRuntimeController|runtime:status:changed"
    - from: "src/renderer/index.tsx"
      to: "src/renderer/app/AppShell.tsx"
      via: "renderer entry mounts recovery/mismatch shell using preload runtimeStatus bridge"
      pattern: "runtimeStatus|<AppShell"
---

<objective>
Close the remaining Phase 1 wiring gaps so runtime recovery and mismatch handling work in the running app, not only in isolated modules.

Purpose: Satisfy the final user-visible outcomes for ARCH-02 while keeping ARCH-01 no-ports guardrails intact.
Output: Main bootstrap wired to supervisor/runtime IPC actions, renderer mounted with AppShell recovery flow, and refreshed verification/UAT evidence.
</objective>

<execution_context>
@C:/Users/aaron/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/aaron/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-CONTEXT.md
@.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-RESEARCH.md
@.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-runtime-guardrails-and-ipc-backbone-VERIFICATION.md
@.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-UAT.md
@.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-02-SUMMARY.md
@.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-03-SUMMARY.md
@.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire main bootstrap to supervisor lifecycle and runtime action channels</name>
  <files>src/main/index.ts, src/main/ipc/runtime-controller.ts</files>
  <action>Instantiate a single `WorkerSupervisor` during app bootstrap, call `start()`, and register runtime status publication (`runtime:get-status` + `runtime:status:changed`) against `mainWindow.webContents`. Add main-process handlers for `runtime:fix-now`, `runtime:retry`, `runtime:restart-app`, and `runtime:copy-report` that map to concrete supervisor recovery behavior and return updated `RuntimeStatus`. Keep `Copy report` execution in main (not renderer) and preserve no-localhost IPC-only transport rules. Replace the failing renderer bootstrap path that depends on inline page `require(...)` with a renderer load path that executes the compiled bundle without using page-context `require`.</action>
  <verify>npm run test -- src/main/ipc/runtime-controller.test.ts src/main/supervisor/retry-policy.test.ts && npm run validate:runtime</verify>
  <done>Main startup owns worker lifecycle and runtime action channels end-to-end; renderer bundle executes on launch without white-window bootstrap failure.</done>
</task>

<task type="auto">
  <name>Task 2: Mount AppShell recovery flow from renderer entry using preload runtime bridge</name>
  <files>src/renderer/index.tsx, src/preload/index.ts</files>
  <action>Update renderer entry to mount `AppShell` so recovery banner and mismatch panel are reachable from the live app while preserving the existing trust badge/privacy content. Ensure runtime status APIs consumed by `AppShell` come from the narrow preload bridge (`runtimeStatus`) and that typing in renderer matches exposed preload shape. Keep locked messaging decisions intact (human-first copy, fix-first mismatch flow, no deferred `Report issue` action).</action>
  <verify>npm run test -- src/renderer/runtime-status/runtime-state-machine.test.ts src/renderer/runtime-status/MismatchRecoveryPanel.test.tsx && npm run build</verify>
  <done>Renderer entry now mounts runtime recovery UX and can receive `runtime:status:changed` updates through preload APIs without broadening renderer privileges.</done>
</task>

<task type="auto">
  <name>Task 3: Re-run phase verification and update UAT/verification reports with post-wiring evidence</name>
  <files>.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-runtime-guardrails-and-ipc-backbone-VERIFICATION.md, .planning/phases/01-runtime-guardrails-and-ipc-backbone/01-UAT.md</files>
  <action>After wiring changes, re-run runtime validation and targeted recovery/mismatch checks, then update the phase verification and UAT documents with current outcomes, evidence commands, and any remaining user-only checks. Explicitly re-evaluate tests 1-3 in UAT now that renderer boot and runtime status wiring are connected. If any truth still fails, record precise artifact-level gap details instead of leaving generic status text.</action>
  <verify>npm run validate:runtime && npm run test -- src/main/ipc/runtime-controller.test.ts src/renderer/runtime-status/runtime-state-machine.test.ts src/renderer/runtime-status/MismatchRecoveryPanel.test.tsx</verify>
  <done>Verification/UAT docs reflect current post-fix behavior and no longer report orphaned runtime lifecycle wiring as unresolved.</done>
</task>

</tasks>

<verification>
Confirm bootstrap wiring by running runtime validation plus targeted runtime-status tests, then verify Phase 1 verification/UAT files are updated with concrete post-wiring evidence.
</verification>

<success_criteria>
Phase 1 reaches user-visible completion: app launches into runtime UI, worker recovery paths execute from live wiring, and mismatch guidance is reachable through main-preload-renderer links.
</success_criteria>

<output>
After completion, create `.planning/phases/01-runtime-guardrails-and-ipc-backbone/01-06-SUMMARY.md`
</output>
